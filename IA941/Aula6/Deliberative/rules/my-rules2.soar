watch 5
learn --off

###############################################################
####  INITIALIZE                                          #####
###############################################################
sp {propose*initialize*deliberative
   (state <s> ^superstate nil 
              -^name 
              ^io.input-link.REACTIVE < 0.5)
-->
    (write (crlf) |Propose INITIALIZE deliberative| )
   (<s> ^operator <o> +)
   (<o> ^name initialize-deliberative)
}

sp {propose*initialize*reactive
   (state <s> ^superstate nil 
             -^name 
             ^io.input-link.REACTIVE > 0.5)
-->
    (write (crlf) |Propose INITIALIZE reactive| )
   (<s> ^operator <o> +)
   (<o> ^name initialize-reactive)
}

sp {apply*initialize-deliberative
   (state <s> ^operator <op> ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^LEAFLET <leaflet>)
   (<creature> ^POSITION <creaturePosition>)
   (<creaturePosition> ^X <creaturePositionX> ^Y <creaturePositionY>)
   (<creature> ^BAG <bag>)
   (<bag> ^Red <bagRed>
          ^Green <bagGreen>
          ^Blue <bagBlue>
          ^Yellow <bagYellow>
          ^Magenta <bagMagenta>
          ^White <bagWhite>)
   (<leaflet> ^Red <leafletRed>
              ^Green <leafletGreen>
              ^Blue <leafletBlue>
              ^Yellow <leafletYellow>
              ^Magenta <leafletMagenta>
              ^White <leafletWhite>)
   (<op> ^name initialize-deliberative)
-->
   (<s> ^name deliberative)
   (<s> ^DESIRED <desired> 
        ^CURRENT <current>
        ^PLAN <plan>
        ^AUX <aux>
        ^LAST <last>
        ^POSITION <position>)
   (<plan> ^COUNT 0 ^START <last>)
   (<current> ^Red <bagRed>
              ^Green <bagGreen>
              ^Blue <bagBlue>
              ^Yellow <bagYellow>
              ^Magenta <bagMagenta>
              ^White <bagWhite>)
   (<desired> ^Red <leafletRed>
              ^Green <leafletGreen>
              ^Blue <leafletBlue>
              ^Yellow <leafletYellow>
              ^Magenta <leafletMagenta>
              ^White <leafletWhite>)

   (<position> ^X <creaturePositionX> ^Y <creaturePositionY>)
}

sp {apply*initialize-reactive
   (state <s> ^operator <op> ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^LEAFLET <leaflet>)
   (<creature> ^POSITION <creaturePosition>)
   (<creaturePosition> ^X <creaturePositionX> ^Y <creaturePositionY>)
   (<creature> ^BAG <bag>)
   (<bag> ^Red <bagRed>
          ^Green <bagGreen>
          ^Blue <bagBlue>
          ^Yellow <bagYellow>
          ^Magenta <bagMagenta>
          ^White <bagWhite>)
   (<leaflet> ^Red <leafletRed>
              ^Green <leafletGreen>
              ^Blue <leafletBlue>
              ^Yellow <leafletYellow>
              ^Magenta <leafletMagenta>
              ^White <leafletWhite>)
   (<op> ^name initialize-reactive)
-->
   (<s> ^name reactive)
   (<s> ^DESIRED <desired> 
        ^CURRENT <current>
        ^PLAN <plan>
        ^AUX <aux>
        ^LAST <last>
        ^POSITION <position>)
   (<plan> ^COUNT 0 ^START <last>)
   (<current> ^Red <bagRed>
              ^Green <bagGreen>
              ^Blue <bagBlue>
              ^Yellow <bagYellow>
              ^Magenta <bagMagenta>
              ^White <bagWhite>)
   (<desired> ^Red <leafletRed>
              ^Green <leafletGreen>
              ^Blue <leafletBlue>
              ^Yellow <leafletYellow>
              ^Magenta <leafletMagenta>
              ^White <leafletWhite>)

   (<position> ^X <creaturePositionX> ^Y <creaturePositionY>)
}

###############################################################
####  WANDER                                              #####
###############################################################

sp {propose*wander*deliberative
   (state <s> ^attribute state
              ^impasse no-change                           
              ^superstate <ss>)
   (<ss> ^io.input-link <il>)
   (<ss> ^superstate nil)
   (<ss> ^name deliberative)
   (<il> ^CREATURE <creature>)
   (<creature> ^SENSOR.VISUAL <visual>)
-->
   (<ss> ^operator <o> +)
   (<o> ^name wander)}
   

sp {apply*wander*deliberative
   (state <s> ^name deliberative ^operator <o>
              ^io <io>)
   (<io> ^output-link <ol>)
   (<o> ^name wander)
-->
   (<ol> ^WANDER <command>)
   (<command> ^Vel 0)
   (<command> ^VelR 2)
   (<command> ^VelL 0)
}
    
sp {apply*wander*remove*move*deliberative
(state <s> ^name deliberative ^operator.name wander
           ^io.output-link <out>)
(<out> ^WANDER <move>)
(<move> ^status complete)
-->
(<out> ^WANDER <move> -)}


###############################################################
####  SEE ENTITY WITH MEMORY COUNT                        #####
###############################################################
sp {propose*see*entity*with*memory*count
   (state <s> ^name << deliberative reactive >> 
              ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^SENSOR.VISUAL.ENTITY <entity>)     
   (<entity> ^TYPE <type> << JEWEL FOOD >>)   
   (<entity> ^COLOR <color>)
   (<entity> ^X <x>)
   (<entity> ^Y <y>) 
   (<entity> ^NAME <name>)
   (<creature> ^MEMORY <memory>)   
   -(<memory> ^ENTITY.NAME <name>)
   (<memory> ^COUNT <quantity> < 1000)
-->
   (<s> ^operator <o> +)
   (<o> ^name seeEntityWithMemoryCount)
   (<o> ^parameterEntity <newEntity>)
   (<newEntity> ^Name <name>)
   (<newEntity> ^Type <type>)
   (<newEntity> ^X <x>)
   (<newEntity> ^Y <y>)
   (<newEntity> ^Color <color>)
   (<newEntity> ^STATUS 0)
}

sp {apply*see*entity*with*memory*count
   (state <s> ^operator <o>
              ^io <io>
              ^POSITION <position>)
   (<position> ^X <positionX> ^Y <positionY>)
   (<io> ^input-link <il>)
   (<io> ^output-link <ol>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^COUNT <quantity>)   
   (<o> ^name seeEntityWithMemoryCount)
   (<o> ^parameterEntity <newEntity>)
   (<newEntity> ^X <x>)
   (<newEntity> ^Y <y>)
   (<newEntity> ^Name <name>)
   (<newEntity> ^Type <type>)
   (<newEntity> ^Color <color>)
-->
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity> ^X <x>)
   (<memoryEntity> ^Y <y>)
   (<memoryEntity> ^NAME <name>)
   (<memoryEntity> ^TYPE <type>)
   (<memoryEntity> ^COLOR <color>) 
   (<memoryEntity> ^STATUS 0)
   (<memoryEntity> ^DISTANCE (sqrt (+ (* (- <positionX> <x>) (- <positionX> <x>)) (* (- <positionY> <y>) (- <positionY> <y>)))))
   (<memory> ^COUNT <quantity> -)
   (<memory> ^COUNT (+ 1 <quantity>))
}

###############################################################
####  SEE ENTITY WITHOUT MEMORY COUNT                     #####
###############################################################
sp {propose*see*entity*without*memory*count
   (state <s> ^name << deliberative reactive >>  ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^SENSOR.VISUAL.ENTITY <entity>)
   (<entity> ^TYPE <type> << JEWEL FOOD >>)
   (<entity> ^X <x>)
   (<entity> ^Y <y>) 
   (<entity> ^NAME <name>)
   (<entity> ^COLOR <color>)
   (<creature> ^MEMORY <memory>)   
   -(<memory> ^ENTITY.NAME <name>)
   -(<memory> ^COUNT <quantity>)
-->
   (<s> ^operator <o> +)
   (<o> ^name seeEntityWithoutMemoryCount)
   (<o> ^parameterEntity <newEntity>)
   (<newEntity> ^Name <name>)
   (<newEntity> ^Type <type>)
   (<newEntity> ^X <x>)
   (<newEntity> ^Y <y>)
   (<newEntity> ^Color <color>)
   (<newEntity> ^STATUS 0)
}

sp {apply*see*entity*without*memory*count
   (state <s> ^operator <o>
              ^io <io>
              ^POSITION <position>)
   (<position> ^X <positionX> ^Y <positionY>)
   (<io> ^input-link <il>)
   (<io> ^output-link <ol>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)  
   (<o> ^name seeEntityWithoutMemoryCount)
   (<o> ^parameterEntity <newEntity>)
   (<newEntity> ^X <x>)
   (<newEntity> ^Y <y>)
   (<newEntity> ^Name <name>)
   (<newEntity> ^Type <type>)
   (<newEntity> ^Color <color>)
-->
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity> ^X <x>)
   (<memoryEntity> ^Y <y>)
   (<memoryEntity> ^NAME <name>)
   (<memoryEntity> ^TYPE <type>)
   (<memoryEntity> ^COLOR <color>)
   (<memoryEntity> ^STATUS 0)
   (<memoryEntity> ^DISTANCE (sqrt (+ (* (- <positionX> <x>) (- <positionX> <x>)) (* (- <positionY> <y>) (- <positionY> <y>)))))
   (<memory> ^COUNT 1)
}

###############################################################
####  MOVE FOOD                                           #####
###############################################################
sp {propose*move*food*deliberative
   (state <s> ^name deliberative
              ^DESIRED <desired>
              ^CURRENT <current>
              ^POSITION <position>
              ^io.input-link <il>)
   (<position> ^X <positionX> ^Y <positionY>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entityInMemory>)
   (<creature> ^POSITION <creaturePosition>)
   (<creaturePosition> ^X <creaturePositionX>)
   (<creaturePosition> ^Y <creaturePositionY>)
   (<entityInMemory> ^TYPE FOOD)
   (<entityInMemory> ^STATUS <status> < 1)
   (<entityInMemory> ^X <entityInMemoryPositionX>)
   (<entityInMemory> ^Y <entityInMemoryPositionY>)
   (<entityInMemory> ^NAME <entityInMemoryName>)
   (<entityInMemory> ^DISTANCE <entityInMemoryDistance>)
   (<creature> ^PARAMETERS.MINFUEL <minFuel>)
   (<creature> ^SENSOR.FUEL <fuel>)
   (<fuel> ^VALUE <= <minFuel> ) 
-->
   (write (crlf) |Propose MOVE to food | <entityInMemoryName> )
   (<s> ^operator <o> +)
   (<o> ^name moveFood)
   (<o> ^parameter <food>)
   (<food> ^distance (sqrt (+ (* (- <positionX> <entityInMemoryPositionX>) (- <positionX> <entityInMemoryPositionX>)) (* (- <positionY> <entityInMemoryPositionY>) (- <positionY> <entityInMemoryPositionY>))))) 
   (<food> ^X <entityInMemoryPositionX>)
   (<food> ^Y <entityInMemoryPositionY>)
   (<food> ^NAME <entityInMemoryName>)
   (<o> ^parameterFuel <minFuel>)
}

sp {apply*move*food*deliberative
   (state <s> ^name deliberative ^operator <o>
              ^io <io>
              ^PLAN <plan>
              ^AUX <aux>
              ^LAST <last>
              ^POSITION <oldPosition> )
   (<plan> ^COUNT <count>)
   (<io> ^input-link <il>)           
   (<io> ^output-link <ol>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entityInMemory>)
   (<entityInMemory> ^DISTANCE <entityInMemoryDistance>)
   (<entityInMemory> ^STATUS <entityInMemoryStatus> = 0)
   (<o> ^name moveFood)
   (<o> ^parameter <food>)
   (<food> ^X <x>)
   (<food> ^Y <y>)
   (<food> ^distance <distance>)
   (<food> ^NAME <name>)

   (<entityInMemory> ^NAME <memoryEntityName> <name>)
-->

   (write (crlf) |Apply MOVE to Food X: |<x> | Y: | <y> | Distance: | <distance> | Name: | <name>)
   (<s> ^POSITION <oldPosition> -
        ^POSITION <newPosition>)
   (<newPosition> ^X <x> ^Y <y>)
   (<entityInMemory> ^DISTANCE <entityInMemoryDistance> -)
   (<entityInMemory> ^DISTANCE 0)
   (<food> ^distance <distance> -)
   (<food> ^distance 0)
   (<aux> ^COMMAND MOVE
          ^Vel 2
          ^VelR 2
          ^VelL 2
          ^X <x>
          ^Y <y>
          ^INDEX (+ <count> 1))
   (<last> ^NEXT <aux>)
   (<s> ^AUX <aux> -)
   (<s> ^AUX <newAux>)
   (<s> ^LAST <last> - ^LAST <aux>)
   (<plan> ^COUNT <count> -
           ^COUNT (+ <count> 1 ))
}

###############################################################
####  EAT FOOD                                            #####
###############################################################
sp {propose*eat*food*deliberative

   (state <s> ^name deliberative ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entity>)
   (<entity> ^TYPE FOOD) 
   (<entity> ^DISTANCE <foodDistance> <= 31)
   (<entity> ^NAME <foodName>)
   (<entity> ^STATUS <memoryItemStatus> = 0)
-->
   (write (crlf) |Propose EAT food: | <foodName>)
   (<s> ^operator <o> +) 
   (<o> ^name eatFood)
   (<o> ^parameter <food>)
   (<food> ^NAME <foodName>)
   (<food> ^distance <foodDistance>)
}

sp {apply*eat*food*deliberative
   (state <s> ^name deliberative ^operator <o>
              ^io <io>
              ^PLAN <plan>
              ^AUX <aux>
              ^LAST <last>
              ^CURRENT <current>)
   (<plan> ^COUNT <count>)
   (<io> ^input-link <il>)      
   (<io> ^output-link <ol>)
   (<o> ^name eatFood)
   (<o> ^parameter.NAME <foodName>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^COUNT <quantity>)  
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity> ^STATUS <status>)
   (<memoryEntity> ^NAME <memoryEntityName> <foodName>)
-->
   (write (crlf) |Apply EAT food: | <foodName> )
   (<aux> ^COMMAND EAT      
          ^Name <foodName>
          ^INDEX (+ <count> 1))
   (<last> ^NEXT <aux>)
   (<s> ^AUX <aux> -)
   (<s> ^AUX <newAux>)
   (<s> ^LAST <last> - ^LAST <aux>)
   (<plan> ^COUNT <count> -
           ^COUNT (+ <count> 1 ))
   (<memoryEntity> ^STATUS <status> -)
   (<memoryEntity> ^STATUS 1)
}

###############################################################
####  MOVE JEWEL                                          #####
###############################################################
sp {propose*move*jewel*deliberative
   (state <s> ^name deliberative
              ^DESIRED <desired>
              ^CURRENT <current>
              ^LAST <last>
              ^POSITION <position>
              ^io.input-link <il>)
   (<position> ^X <positionX> ^Y <positionY>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entityInMemory>)
   (<creature> ^POSITION <creaturePosition>)
   (<creaturePosition> ^X <creaturePositionX>)
   (<creaturePosition> ^Y <creaturePositionY>)
   (<entityInMemory> ^TYPE JEWEL)
   (<entityInMemory> ^STATUS <status> < 1)
   (<entityInMemory> ^X <entityInMemoryPositionX>)
   (<entityInMemory> ^Y <entityInMemoryPositionY>)
   (<entityInMemory> ^NAME <entityInMemoryName>)
   (<entityInMemory> ^COLOR <entityInMemoryColor>)
   (<entityInMemory> ^DISTANCE <entityInMemoryDistance> <> 0)
   (<desired> ^<entityInMemoryColor> <desiredColor>)
   (<current> ^<entityInMemoryColor> <currentColor> < <desiredColor>)
-->
   (write (crlf) |Propose MOVE to jewel: | <entityInMemoryName> | color: | <entityInMemoryColor> )
   (<s> ^operator <o> +)
   (<o> ^name moveJewel)
   (<o> ^parameter <jewel>)
   (<jewel> ^distance (sqrt (+ (* (- <positionX> <entityInMemoryPositionX>) (- <positionX> <entityInMemoryPositionX>)) (* (- <positionY> <entityInMemoryPositionY>) (- <positionY> <entityInMemoryPositionY>))))) 
   (<jewel> ^X <entityInMemoryPositionX>)
   (<jewel> ^Y <entityInMemoryPositionY>)
   (<jewel> ^NAME <entityInMemoryName>)
   (<jewel> ^COLOR <entityInMemoryColor>)
}

sp {apply*move*jewel*deliberative
   (state <s> ^name deliberative ^operator <o>
              ^io <io>
              ^PLAN <plan>
              ^AUX <aux>
              ^LAST <last>
              ^POSITION <oldPosition> )
   (<plan> ^COUNT <count>)
   (<io> ^input-link <il>)           
   (<io> ^output-link <ol>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entityInMemory>)
   (<entityInMemory> ^STATUS <entityInMemoryStatus> < 1)
   (<o> ^name moveJewel)
   (<o> ^parameter <jewel>)
   (<jewel> ^X <x>)
   (<jewel> ^Y <y>)
   (<jewel> ^COLOR <color>)
   (<jewel> ^distance <distance> <> 0)
   (<jewel> ^NAME <name>)
   (<entityInMemory> ^NAME <memoryEntityName> <name>)
-->

   (write (crlf) |Apply MOVE to Jewel Color: | <color> | X: |<x> | Y: | <y> | Distance: | <distance> | Name: | <name>)
   (<s> ^POSITION <oldPosition> -
        ^POSITION <newPosition>)
   (<newPosition> ^X <x> ^Y <y>)
   (<entityInMemory> ^DISTANCE <entityInMemoryDistance> -)
   (<entityInMemory> ^DISTANCE 0)
   (<jewel> ^distance <distance> -)
   (<jewel> ^distance 0)
   (<aux> ^COMMAND MOVE
          ^Vel 2
          ^VelR 2
          ^VelL 2
          ^X <x>
          ^Y <y>
          ^INDEX (+ <count> 1))
   (<last> ^NEXT <aux>)
   (<s> ^AUX <aux> -)
   (<s> ^AUX <newAux>)
   (<s> ^LAST <last> - ^LAST <aux>)
   (<plan> ^COUNT <count> -
           ^COUNT (+ <count> 1 ))
}  

###############################################################
####  GET JEWEL                                           #####
###############################################################
sp {propose*get*jewel*deliberative
   (state <s> ^name deliberative ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entity>)
   (<entity> ^TYPE JEWEL) 
   (<entity> ^DISTANCE <jewelDistance> <= 31)
   (<entity> ^NAME <jewelName>)
   (<entity> ^COLOR <jewelColor>)
   (<entity> ^STATUS <memoryItemStatus> = 0)
   (<s> ^DESIRED <desired>)
   (<s> ^CURRENT <current>)
   (<desired> ^<jewelColor> <dcolor> > 0)
   #(<current> ^<jewelColor> <ccolor> < <dcolor>)
-->
   (write (crlf) |Propose GET jewel: | <jewelName> | color: | <jewelColor> )
   (<s> ^operator <o> +) 
   (<o> ^name getJewel)
   (<o> ^parameter <jewel>)
   (<jewel> ^NAME <jewelName>)
   (<jewel> ^COLOR <jewelColor>)
   (<jewel> ^distance <jewelDistance>)
}

sp {apply*get*jewel*deliberative
   (state <s> ^name deliberative ^operator <o>
              ^io <io>
              ^PLAN <plan>
              ^AUX <aux>
              ^LAST <last>
              ^CURRENT <current>)
   (<plan> ^COUNT <count>)
   (<io> ^input-link <il>)      
   (<io> ^output-link <ol>)
   (<o> ^name getJewel)
   (<o> ^parameter.NAME <jewelName>)
   (<o> ^parameter.COLOR <jewelColor>)
   (<il> ^CREATURE <creature>) 
   (<creature> ^BAG <bag>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^COUNT <quantity>)  
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity> ^COLOR <color>)
   (<memoryEntity> ^STATUS <status>)
   (<bag> ^<color> <bagColor>)
   (<current> ^<color> <curColor>)
   (<memoryEntity> ^NAME <memoryEntityName> <jewelName>)
   
-->
   (write (crlf) |Apply GET jewel: | <jewelName> | color: | <color> )
   (<aux> ^COMMAND GET      
          ^Name <jewelName>
          ^INDEX (+ <count> 1))
   (<last> ^NEXT <aux>)
   (<s> ^AUX <aux> -)
   (<s> ^AUX <newAux>)
   (<s> ^LAST <last> - ^LAST <aux>)
   (<plan> ^COUNT <count> -
           ^COUNT (+ <count> 1 ))
   (<memoryEntity> ^STATUS <status> -)
   (<memoryEntity> ^STATUS 1)
   (<current> ^<color> <curColor> -
              ^<color> ( + <curColor> 1) )
   (write (crlf) |Current |<color>|: |  (+ <curColor> 1 ))
}

###############################################################
####  HIDE JEWEL                                          #####
###############################################################
sp {propose*hide*jewel*deliberative
   (state <s> ^name deliberative ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entity>)
   (<entity> ^TYPE JEWEL) 
   (<entity> ^DISTANCE <jewelDistance> <= 31)
   (<entity> ^NAME <jewelName>)
   (<entity> ^COLOR <jewelColor>)
   (<entity> ^STATUS <memoryItemStatus> = 0)
   (<s> ^DESIRED <desired>)
   (<s> ^CURRENT <current>)
   (<desired> ^<jewelColor> <dcolor> < 1)
   (<current> ^<jewelColor> <ccolor> >= <dcolor>)
-->
   (write (crlf) |Propose HIDE jewel: | <jewelName> | color: | <jewelColor> )
   (<s> ^operator <o> +) 
   (<o> ^name hideJewel)
   (<o> ^parameter <jewel>)
   (<jewel> ^NAME <jewelName>)
   (<jewel> ^distance <jewelDistance>)
}

sp {apply*hide*jewel*deliberative
   (state <s> ^name deliberative ^operator <o>
              ^io <io>
              ^PLAN <plan>
              ^AUX <aux>
              ^LAST <last>
              ^CURRENT <current>)
   (<plan> ^COUNT <count>)
   (<io> ^input-link <il>)      
   (<io> ^output-link <ol>)
   (<o> ^name hideJewel)
   (<o> ^parameter.NAME <jewelName>)
   (<il> ^CREATURE <creature>) 
   (<creature> ^BAG <bag>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^COUNT <quantity>)  
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity> ^COLOR <color>)
   (<memoryEntity> ^STATUS <status>)
   (<bag> ^<color> <bagColor>)
   (<current> ^<color> <curColor>)
   (<memoryEntity> ^NAME <memoryEntityName> <jewelName>)
-->
   (write (crlf) |Apply HIDE jewel: | <memoryEntityName> | color: | <color> )
   (<aux> ^COMMAND HIDE      
          ^Name <jewelName>
          ^INDEX (+ <count> 1))
   (<last> ^NEXT <aux>)
   (<s> ^AUX <aux> -)
   (<s> ^AUX <newAux>)
   (<s> ^LAST <last> - ^LAST <aux>)
   (<plan> ^COUNT <count> -
           ^COUNT (+ <count> 1 ))
   (<memoryEntity> ^STATUS <status> -)
   (<memoryEntity> ^STATUS 1)
}

###############################################################
####  MOVE DELIVERY SPOT                                  #####
###############################################################
sp {propose*move*delivery*deliberative
   (state <s> ^name deliberative
              ^CURRENT <current>
              ^DESIRED <desired>
              ^POSITION <position>
              ^LAST <last>
              ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^DELIVERYSPOT <deliverySpot>)
   (<position> ^X <positionX> ^Y <positionY>)
   (<deliverySpot> ^X <deliverySpotX>)
   (<deliverySpot> ^Y <deliverySpotY>)
   (<deliverySpot> ^DISTANCE <distance> > 0)
   (<current> ^Red <r>
              ^Green <g>
              ^Blue <b>
              ^Yellow <y>
              ^Magenta <m>
              ^White <w>)
   (<desired> ^Red <r>
          ^Green <g>
          ^Blue <b>
          ^Yellow <y>
          ^Magenta <m>
          ^White <w>
   )
-->
   (write (crlf) |Propose MOVE to Delivery Spot|)
   (<s> ^operator <o> +)
   (<o> ^name moveDeliverySpot)
   (<o> ^parameter <spot>)
   (<spot> ^distance (sqrt (+ (* (- <positionX> <deliverySpotX>) (- <positionX> <deliverySpotX>)) (* (- <positionY> <deliverySpotY>) (- <positionY> <deliverySpotY>)))))
   (<spot> ^X <deliverySpotX>)
   (<spot> ^Y <deliverySpotY>)
}

sp {apply*move*delivery*deliberative
    (state <s> ^name deliberative ^operator <o>
              ^io <io>
              ^PLAN <plan>
              ^AUX <aux>
              ^LAST <last>
              ^POSITION <oldPosition>)
   (<o> ^name moveDeliverySpot)
   (<o> ^parameter <deliverySpot>)
   (<plan> ^COUNT <count>)
   (<deliverySpot> ^X <deliverySpotX>)
   (<deliverySpot> ^Y <deliverySpotY>)
   (<deliverySpot> ^distance <distance>)
-->

   (write (crlf) |Apply MOVE to Delivery Spot X: |<deliverySpotX> | Y: | <deliverySpotY> | Distance: | <distance> )
   (<s> ^POSITION <oldPosition> -
        ^POSITION <newPosition>)
   (<newPosition> ^X <deliverySpotX> ^Y <deliverySpotY>)
   (<deliverySpot> ^distance <distance> -)
   (<deliverySpot> ^distance 0)
   (<aux> ^COMMAND MOVE
          ^Vel 2
          ^VelR 2
          ^VelL 2
          ^X <deliverySpotX>
          ^Y <deliverySpotY>
          ^INDEX (+ <count> 1))
   (<last> ^NEXT <aux>)
   (<s> ^AUX <aux> -)
   (<s> ^AUX <newAux>)
   (<s> ^LAST <last> - ^LAST <aux>)
   (<plan> ^COUNT <count> -
           ^COUNT (+ <count> 1 ))
}

###############################################################
####  DELIVER LEAFLET                                     #####
###############################################################
sp {propose*deliver*leaflet*deliberative
    (state <s> ^name deliberative
               ^CURRENT <current>
               ^DESIRED <desired>
               ^POSITION <position>
               ^LAST <last>
               ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^LEAFLET <leaflet>)
   (<leaflet> ^ID <leafletId>)
   (<leaflet> ^PAYMENT <leafletPayment>)
   (<creature> ^DELIVERYSPOT <deliverySpot>)
   (<deliverySpot> ^DISTANCE <distance> = 0.0)
   (<current> ^Red <r>
          ^Green <g>
          ^Blue <b>
          ^Yellow <y>
          ^Magenta <m>
          ^White <w>)
   (<desired> ^Red <r>
          ^Green <g>
          ^Blue  <b>
          ^Yellow <y>
          ^Magenta <m>
          ^White <w>)
-->
    (write (crlf) |Propose DELIVER leaflet:  | <leafletId>)
    (<s> ^operator <o> +)
    (<o> ^name deliverLeaflet)
    (<o> ^parameter <leafletToDeliver>)
    (<leafletToDeliver> ^ID <leafletId>)
    (<leafletToDeliver> ^PAYMENT <leafletPayment>)
}

sp {apply*deliver*leaflet*deliberative
   (state <s> ^name deliberative ^operator <o>
              ^io <io>
              ^PLAN <plan>
              ^AUX <aux>
              ^LAST <last>)
   (<io> ^input-link <il>)      
   (<io> ^output-link <ol>)
   (<o> ^name deliverLeaflet)
   (<il> ^CREATURE <creature>)
   (<creature> ^LEAFLET <leaflet>)
   (<o> ^parameter <leafletToDeliver>)
   (<leafletToDeliver> ^ID <leafletToDeliverID>)
   (<leafletToDeliver> ^PAYMENT <leafletToDeliverPayment>)

   
   (<leaflet> ^ID <leafletId> <leafletToDeliverID>)
-->
   (write (crlf) |Apply DELIVER leaflet: | <leafletId>)
   (<aux> ^COMMAND DELIVER
          ^ID <leafletId>
          ^INDEX (+ <count> 1))
   (<last> ^NEXT <aux>)
   (<s> ^AUX <aux> -)
   (<s> ^AUX <newAux>)
   (<s> ^LAST <last> - ^LAST <aux>)
   (<plan> ^COUNT <count> -
           ^COUNT (+ <count> 1 ))
}
###############################################################
####  AVOID BRICK                                         #####
###############################################################
sp {propose*avoidBrick
   (state <s> ^name << deliberative reactive >> ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^SENSOR.VISUAL.ENTITY <entity>)
   (<entity> ^TYPE BRICK)
   (<entity> ^DISTANCE <distance> <= 61)      
-->
   (<s> ^operator <o> +)     
   (<o> ^name avoidBrick)
   (<o> ^parameter <distance>)
}

sp {apply*avoidBrick
   (state <s> ^name << deliberative reactive >> ^operator <o>
              ^io <io>)
   (<o> ^name avoidBrick)
   (<o> ^parameter <distance>)              
   (<io> ^output-link <ol>)
-->
   (<ol> ^MOVE <command>)
   (<command> ^Vel  0)
   (<command> ^VelR (* 55 (/ <distance>)))
   (<command> ^VelL 0)
}

sp {apply*avoidBrick*remove*entity*memory
(state <s> ^name << deliberative reactive >> ^operator <o>
           ^io.input-link <il>)
(<o> ^name avoidBrick)
(<o> ^entityName <entityName>)
(<il> ^CREATURE <creature>)
(<creature> ^MEMORY <memory>)
(<memory> ^COUNT <quantity>)
(<memory> ^ENTITY <entityInMemory>)           
(<entityInMemory> ^NAME <name> <entityName>)
-->
(<memory> ^ENTITY <entityInMemory> -)
(<memory> ^COUNT <quantity> -
          ^COUNT (- <quantity> 1))
}
 
###############################################################
####  SUCCESS STATE RECOGNITION                           #####
###############################################################

sp {detect*state*success
   (state <s> ^name deliberative ^DESIRED <desired>
              ^CURRENT <current>
              ^PLAN <plan>
              ^POSITION <position>
              ^io.input-link <il>
              ^io.output-link <ol>)
   (<plan> ^START <start>)
   (<start> ^NEXT <begin>)
   (<current> ^Red <r>
          ^Green <g>
          ^Blue <b>
          ^Yellow <y>
          ^Magenta <m>
          ^White <w>)
   (<desired> ^Red <r>
          ^Green <g>
          ^Blue <b>
          ^Yellow <y>
          ^Magenta <m>
          ^White <w>
   )
   
-->
   (<ol> ^PLAN <begin>)
   (write (crlf) |LEAFLET COMPLETED| )  
   (halt)
}


###################################  WANDER  ###################################
# This operator will make the agent to walk ahead at the enviroment
# Propose*wander:
sp {propose*wander
   (state <s> ^attribute state
              ^impasse no-change                           
              ^superstate <ss>)
   (<ss> ^io.input-link <il>)
   (<ss> ^name reactive)
   (<ss> ^superstate nil)
   (<il> ^CREATURE <creature>)
   (<creature> ^SENSOR.VISUAL <visual>)
-->
   (<ss> ^operator <o> +)
   (<o> ^name wander)}
   
# Apply*wander:
# If the wander operator is selected, then generate an output command to it 
sp {apply*wander
   (state <s> ^name reactive ^operator <o>
              ^io <io>)
   (<io> ^output-link <ol>)
   (<o> ^name wander)
-->
   (<ol> ^MOVE <command>)
   (<command> ^Vel 0)
   (<command> ^VelR 3)
   (<command> ^VelL 0)
}
    
# If the wander operator is selected,
# and there is a completed move command on the output link,
# then remove that command.   
sp {apply*wander*remove*move
(state <s> ^name reactive ^operator.name wander
           ^io.output-link <out>)
(<out> ^MOVE <move>)
(<move> ^status complete)
-->
(<out> ^MOVE <move> -)}   
 

##############################  MOVE FOOD  #####################################
# This operator will make the agent go straight to the food

# Propose*move*food:
sp {propose*move*food
   (state <s> ^name reactive ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entityInMemory>)
   (<creature> ^POSITION <creaturePosition>)
   (<creaturePosition> ^X <creaturePositionX>)
   (<creaturePosition> ^Y <creaturePositionY>)
   (<entityInMemory> ^TYPE FOOD)
   (<entityInMemory> ^X <entityInMemoryPositionX>)
   (<entityInMemory> ^Y <entityInMemoryPositionY>)
   (<entityInMemory> ^NAME <entityInMemoryName>) 
   (<creature> ^PARAMETERS.MINFUEL <minFuel>)
   (<creature> ^SENSOR.FUEL <fuel>)
   (<fuel> ^VALUE <= <minFuel> ) 
-->
   (<s> ^operator <o> +)
   (<o> ^name moveFood)
   (<o> ^parameter <food>)
   (<food> ^distance (sqrt (+ (* (- <creaturePositionX> <entityInMemoryPositionX>) (- <creaturePositionX> <entityInMemoryPositionX>)) (* (- <creaturePositionY> <entityInMemoryPositionY>) (- <creaturePositionY> <entityInMemoryPositionY>)))))
   (<food> ^X <entityInMemoryPositionX>)
   (<food> ^Y <entityInMemoryPositionY>)
   (<food> ^NAME <entityInMemoryName>)
   (<o> ^parameterFuel <minFuel>)}
   
# Apply*move*food:
# If the move operator is selected, then generate an output command to it 
sp {apply*move*food
   (state <s> ^name reactive ^operator <o>
              ^io <io>)
   (<io> ^input-link <il>)             
   (<io> ^output-link <ol>)
   (<o> ^name moveFood)
   (<o> ^parameter <food>)
   (<food> ^X <x>)
   (<food> ^Y <y>)
   (<food> ^NAME <entityInMemoryName>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entityInMemory>)
   (<entityInMemory> ^NAME <entityInMemoryName>)
-->
   (<ol> ^MOVE <command>)
   (<command> ^Vel 2)
   (<command> ^VelR 2)
   (<command> ^VelL 2)
   (<command> ^X <x>)
   (<command> ^Y <y>)
   #(halt)
}
  
# Apply*moveFood*remove-move:
# If the moveFood operator is selected,
# and there is a completed move command on the output link,
# then remove that command.   
sp {apply*moveFood*remove-move
(state <s> ^name reactive ^operator.name moveFood
           ^io.output-link <out>)
(<out> ^MOVE <move>)
(<move> ^status complete)
-->
(<out> ^MOVE <move> -)}   

#Remove the food from memory because it is not there anymore 
sp {apply*moveFood*remove*food
    (state <s> ^name reactive ^operator <o>
           ^io.input-link <il>)
    (<o> ^name moveFood)
    (<o> ^parameter <food>)
    (<food> ^X <x>)
    (<food> ^Y <y>)
    (<il> ^CREATURE <creature>)
    (<creature> ^MEMORY <memory>)
    (<memory> ^ENTITY <entityInMemory>) 
    (<memory> ^COUNT <quantity>)
    (<entityInMemory> ^X <x>)
    (<entityInMemory> ^Y <y>)      
    -(<creature> ^SENSOR.VISUAL.ENTITY.X <entityX> <x>)
    -(<creature> ^SENSOR.VISUAL.ENTITY.Y <entityY> <y>)
-->
    (<memory> ^ENTITY <entityInMemory> -)
    (<memory> ^COUNT <quantity> -
              ^COUNT (- <quantity> 1))}   

###############################  EAT FOOD  #####################################
# This operator will make the agent eat the food

# Propose*eat*food:
sp {propose*eat*food
   (state <s> ^name reactive ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^SENSOR.VISUAL.ENTITY <entity>)
   (<entity> ^TYPE FOOD) 
   (<entity> ^DISTANCE <foodDistance> < 30)
   (<entity> ^NAME <foodName>)
   (<creature> ^MEMORY.ENTITY.NAME <memoryItemName> <foodName>)     
-->
   (<s> ^operator <o> +)
   (<o> ^name eatFood)
   (<o> ^parameter <food>)
   (<food> ^NAME <foodName>)
   (<food> ^DISTANCE <foodDistance>)}
   
# Apply*eat*food:
# If the move operator is selected, then generate an output command to it 
sp {apply*eat*food
   (state <s> ^name reactive ^operator <o>
              ^io <io>)
   (<io> ^input-link <il>)      
   (<io> ^output-link <ol>)
   (<o> ^name eatFood)
   (<o> ^parameter.NAME <foodName>)
   (<il> ^CREATURE <creature>) 
   (<creature> ^MEMORY <memory>)
   (<memory> ^COUNT <quantity>)  
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity> ^NAME <memoryEntityName> <foodName>)
   - (<ol> ^EAT <something>)
-->
   (<ol> ^EAT <command>)
   (<command> ^Name <foodName>)
   (<memory> ^COUNT <quantity> -
             ^COUNT (- <quantity> 1))
   (<memory> ^ENTITY <memoryEntity> -)
   #(halt)
}
  
# Apply*eat*remove-move:
# If the eatFood operator is selected,
# and there is a completed move command on the output link,
# then remove that command.   
sp {apply*eatFood*remove-eat
(state <s> ^name reactive ^operator <o>            
           ^io.output-link <out>)
(<o> ^name eatFood)
(<o> ^parameter.name <foodName>)
(<out> ^EAT <eat>)
(<eat> ^status complete)
-->
(<out> ^EAT <eat> -)}

#############################  MOVE JEWEL  #####################################
# This operator will make the agent go straight to the jewel

# Propose*move*jewel:
sp {propose*move*jewel
   (state <s> ^name reactive ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entityInMemory>)
   (<creature> ^POSITION <creaturePosition>)
   (<creaturePosition> ^X <creaturePositionX>)
   (<creaturePosition> ^Y <creaturePositionY>)
   (<entityInMemory> ^TYPE JEWEL)
   (<entityInMemory> ^X <entityInMemoryPositionX>)
   (<entityInMemory> ^Y <entityInMemoryPositionY>)
   (<entityInMemory> ^NAME <entityInMemoryName>)
   (<entityInMemory> ^COLOR <entityInMemoryColor>)
   (<creature> ^LEAFLET <leaflet>)
   (<creature> ^BAG <bag>)
   (<leaflet> ^<entityInMemoryColor> <leafletQtd>)
   (<leaflet> ^<entityInMemoryColor> > 0)
   (<bag> ^<entityInMemoryColor> < <leafletQtd>)
-->
   (write (crlf) |Propose MOVE to  jewel color  | <entityInMemoryColor> )
   (<s> ^operator <o> +)
   (<o> ^name moveJewel)
   (<o> ^parameter <jewel>)
   (<jewel> ^distance (sqrt (+ (* (- <creaturePositionX> <entityInMemoryPositionX>) (- <creaturePositionX> <entityInMemoryPositionX>)) (* (- <creaturePositionY> <entityInMemoryPositionY>) (- <creaturePositionY> <entityInMemoryPositionY>)))))
   (<jewel> ^X <entityInMemoryPositionX>)
   (<jewel> ^Y <entityInMemoryPositionY>)
   (<jewel> ^NAME <entityInMemoryName>)
   (<jewel> ^COLOR <entityInMemoryColor>)}
   
# Apply*move*jewel:
# If the move operator is selected, then generate an output command to it 
sp {apply*move*jewel
   (state <s> ^name reactive ^operator <o>
              ^io <io>)
   (<io> ^input-link <il>)           
   (<io> ^output-link <ol>)
   (<o> ^name moveJewel)
   (<o> ^parameter <jewel>)
   (<jewel> ^X <x>)
   (<jewel> ^Y <y>)
   (<jewel> ^NAME <entityInMemoryName>)
   (<il> ^CREATURE <creature>)
   (<creature> ^MEMORY <memory>)
   (<memory> ^ENTITY <entityInMemory>)
   (<entityInMemory> ^NAME <entityInMemoryName>)
-->
   (<ol> ^MOVE <command>)
   (<command> ^Vel 2)
   (<command> ^VelR 2)
   (<command> ^VelL 2)
   (<command> ^X <x>)
   (<command> ^Y <y>)
   #(halt)
}

  
# Apply*moveJewel*remove-move:
# If the moveJewel operator is selected,
# and there is a completed move command on the output link,
# then remove that command.   
sp {apply*moveJewel*remove-move
    (state <s> ^name reactive ^operator.name moveJewel
           ^io.output-link <out>)
    (<out> ^MOVE <move>)
    (<move> ^status complete)
-->
    (<out> ^MOVE <move> -)
}   

#Remove the jewel From memory because de jewel is not there 
sp {apply*moveJewel*remove*jewel
    (state <s> ^name reactive ^operator <o>
               ^io.input-link <il>)
    (<o> ^name moveJewel)
    (<o> ^parameter <jewel>)
    (<jewel> ^X <x>)
    (<jewel> ^Y <y>)
    (<il> ^CREATURE <creature>)
    (<creature> ^MEMORY <memory>)
    (<memory> ^ENTITY <entityInMemory>) 
    (<memory> ^COUNT <quantity>)
    (<entityInMemory> ^X <x>)
    (<entityInMemory> ^Y <y>)      
    -(<creature> ^SENSOR.VISUAL.ENTITY.X <entityX> <x>)
    -(<creature> ^SENSOR.VISUAL.ENTITY.Y <entityY> <y>)
-->
    (<memory> ^ENTITY <entityInMemory> -)
    (<memory> ^COUNT <quantity> -
              ^COUNT (- <quantity> 1))}   

##############################  GET JEWEL  #####################################
# This operator will make the agent get the jewel

# Propose*get*jewel:
sp {propose*get*jewel
   (state <s> ^name reactive ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^SENSOR.VISUAL.ENTITY <entity>)
   (<entity> ^TYPE JEWEL) 
   (<entity> ^DISTANCE <jewelDistance> < 30)
   (<entity> ^NAME <jewelName>)
   (<entity> ^COLOR <jewelColor>)
   (<creature> ^MEMORY.ENTITY.NAME <memoryItemName> <jewelName>)
   (<creature> ^LEAFLET <leaflet>)
   (<leaflet> ^<jewelColor> > 0)
-->
   (write (crlf) |Propose get jewel color  | <jewelColor> )

   (<s> ^operator <o> +)
   (<o> ^name getJewel)
   (<o> ^parameter <jewel>)
   (<jewel> ^NAME <jewelName>)
   (<jewel> ^DISTANCE <jewelDistance>)}
   
# Apply*get*jewel:
# If the move operator is selected, then generate an output command to it 
sp {apply*get*jewel
   (state <s> ^name reactive ^operator <o>
              ^io <io>)
   (<io> ^input-link <il>)      
   (<io> ^output-link <ol>)
   (<o> ^name getJewel)
   (<o> ^parameter.NAME <jewelName>)
   (<il> ^CREATURE <creature>) 
   (<creature> ^MEMORY <memory>)
   (<memory> ^COUNT <quantity>)  
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity> ^NAME <memoryEntityName> <jewelName>)
   - (<ol> ^GET <anything>)   # Colocado por Ricardo
-->
   (<ol> ^GET <command>)
   (<command> ^Name <jewelName>)
   (<memory> ^COUNT <quantity> -
             ^COUNT (- <quantity> 1))
   (<memory> ^ENTITY <memoryEntity> -)
   #(halt)
}
  
# Apply*get*remove-move:
# If the getJewel operator is selected,
# and there is a completed move command on the output link,
# then remove that command.   
sp {apply*getJewel*remove-get
    (state <s> ^name reactive ^operator <o>            
               ^io.output-link <out>)
    (<o> ^name getJewel)
    (<o> ^parameter.name <jewelName>)
    (<out> ^GET <move>)
    (<move> ^status complete)
-->
    (<out> ^GET <move> -)
}

##############################  HIDE JEWEL  #####################################
# This operator will make the agent HIDE the jewel

# Propose*hide*jewel:
sp {propose*hide*jewel
   (state <s> ^name reactive ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^SENSOR.VISUAL.ENTITY <entity>)
   (<entity> ^TYPE JEWEL) 
   (<entity> ^DISTANCE <jewelDistance> < 30)
   (<entity> ^NAME <jewelName>)
   (<entity> ^COLOR <jewelColor>)
   (<creature> ^MEMORY.ENTITY.NAME <memoryItemName> <jewelName>)
   (<creature> ^LEAFLET <leaflet>)
   (<leaflet> ^<jewelColor> < 1)
-->
   (write (crlf) |Propose hide jewel color  | <jewelColor>)
   (<s> ^operator <o> + )
   (<o> ^name hideJewel)
   (<o> ^parameter <jewel>)
   (<jewel> ^NAME <jewelName>)
   (<jewel> ^DISTANCE <jewelDistance>)}
   
# Apply*hide*jewel:
# If the move operator is selected, then generate an output command to it 
sp {apply*hide*jewel
   (state <s> ^name reactive ^operator <o>
              ^io <io>)
   (<io> ^input-link <il>)      
   (<io> ^output-link <ol>)
   (<o> ^name hideJewel)
   (<o> ^parameter.NAME <jewelName>)
   (<il> ^CREATURE <creature>) 
   (<creature> ^MEMORY <memory>)
   (<memory> ^COUNT <quantity>)  
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity> ^NAME <memoryEntityName> <jewelName>)
   - (<ol> ^HIDE <anything>)   # Colocado por Ricardo
-->
   (<ol> ^HIDE <command>)
   (<command> ^Name <jewelName>)
   (<memory> ^COUNT <quantity> -
             ^COUNT (- <quantity> 1))
   (<memory> ^ENTITY <memoryEntity> -)
   #(halt)
}
  
# Apply*hide*remove-move:
# If the hideJewel operator is selected,
# and there is a completed move command on the output link,
# then remove that command.   
sp {apply*hideJewel*remove-hide
    (state <s> ^name reactive ^operator <o>            
              ^io.output-link <out>)
    (<o> ^name hideJewel)
    (<o> ^parameter.name <jewelName>)
    (<out> ^HIDE <move>)
    (<move> ^status complete)
-->
    (<out> ^HIDE <move> -)
}


#############################  MOVE DELIVERY SPOT  #####################################
# This operator will make the agent go straight to the delivery spot

# Propose*move*jewel:
sp {propose*move*delivery
   (state <s> ^name reactive ^io.input-link <il>)
   (<il> ^CREATURE <creature>)
   (<creature> ^POSITION <creaturePosition>)
   (<creaturePosition> ^X <creaturePositionX>)
   (<creaturePosition> ^Y <creaturePositionY>)
   (<creature> ^DELIVERYSPOT <deliverySpot>)
   (<deliverySpot> ^X <deliverySpotX>)
   (<deliverySpot> ^Y <deliverySpotY>)
   (<creature> ^LEAFLET <leaflet>)
   (<leaflet> ^READY > 0)
-->
   (write (crlf) |Propose MOVE to Delivery Spot|)
   (<s> ^operator <o> +)
   (<o> ^name moveDeliverySpot)
   (<o> ^parameter <spot>)
   (<spot> ^distance (sqrt (+ (* (- <creaturePositionX> <deliverySpotX>) (- <creaturePositionX> <deliverySpotX>)) (* (- <creaturePositionY> <deliverySpotY>) (- <creaturePositionY> <deliverySpotY>)))))
   (<spot> ^X <deliverySpotX>)
   (<spot> ^Y <deliverySpotY>)
}
# Apply*move*delivery:
# If the move operator is selected, then generate an output command to it 
sp {apply*move*delivery
   (state <s> ^name reactive ^operator <o>
              ^io <io>)
   (<io> ^input-link <il>)           
   (<io> ^output-link <ol>)
   (<o> ^name moveDeliverySpot)
   (<o> ^parameter <spot>)
   (<spot> ^X <x>)
   (<spot> ^Y <y>)
   (<il> ^CREATURE <creature>)
   
-->
   (<ol> ^MOVE <command>)
   (<command> ^Vel 2)
   (<command> ^VelR 2)
   (<command> ^VelL 2)
   (<command> ^X <x>)
   (<command> ^Y <y>)
   #(halt)
}

  
# Apply*moveDeliverySpot*remove-move:
# If the moveDeliverySpot operator is selected,
# and there is a completed move command on the output link,
# then remove that command.   
sp {apply*moveDeliverySpot*remove-move
    (state <s> ^name reactive ^operator.name moveDeliverySpot
           ^io.output-link <out>)
    (<out> ^MOVE <move>)
    (<move> ^status complete)
-->
    (<out> ^MOVE <move> -)
}   

#############################  DELIVER LEAFLET #################################
# This operator will make agent deliver leaflet
# Propose*deliver*leaflet:
sp {propose*deliver*leaflet
    (state <s> ^name reactive ^io.input-link <il>)
    (<il> ^CREATURE <creature>)
    (<creature> ^DELIVERYSPOT <spot>)
    (<spot> ^DISTANCE <= 75 )
    (<creature> ^LEAFLET <leaflet>)
    (<leaflet> ^ID <leafletId>)
    (<leaflet> ^READY > 0)
-->
    (write (crlf) |Propose deliver leaflet  | <leafletId>)
    (<s> ^operator <o> +)
    (<o> ^name deliverLeaflet)
    (<o> ^parameter <leafletToDeliver>)
    (<leafletToDeliver> ^ID <leafletId>)
}

# Apply*deliver*leaflet
sp {apply*deliver*leaflet
   (state <s> ^name reactive ^operator <o>
              ^io <io>)
   (<io> ^input-link <il>)      
   (<io> ^output-link <ol>)
   (<o> ^name deliverLeaflet)
   (<o> ^parameter.ID <leafletId>)
   (<il> ^CREATURE <creature>)
-->
   (<ol> ^DELIVER <command>)
   (<command> ^ID <leafletId>)
}

# Apply*deliver*remove-move:
# If the deliverLeaflet operator is selected,
# and there is a completed move command on the output link,
# then remove that command.   
sp {apply*deliverLeaflet*remove-deliver
    (state <s> ^name reactive ^operator <o>            
              ^io.output-link <out>)
    (<o> ^name deliverLeaflet)
    (<o> ^parameter.ID <leafletId>)
    (<out> ^DELIVER <move>)
    (<move> ^status complete)
-->
    (<out> ^DELIVER <move> -)
}






##################  OPERATORS PREFERENCES AND IMPASSE SOLVE  ###################

#SEE AND PROCESS ENTITY

# Move Jewel or Move Food vs See Entity
sp {moveJewel*seeEntity*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name << seeEntityWithMemoryCount seeEntityWithoutMemoryCount >>)
(<o2> ^name << moveJewel moveFood moveDeliverySpot >>)
-->
(<s> ^operator <o> > <o2>)} 

# See Entity With Memory vs Avoid Brick
sp {avoidBrick*seeEntityWithMemory*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name avoidBrick)
(<o2> ^name << seeEntityWithMemoryCount seeEntityWithoutMemoryCount >>)
-->
(<s> ^operator <o> > <o2>)} 

# See Ententy Without Memory Preferences
sp {seeEntity*without*memory*preferences
(state <s> ^operator <o> +)
(<o> ^name << seeEntityWithMemoryCount seeEntityWithoutMemoryCount >>)
-->
(<s> ^operator <o> =)}


#DELIVER

# GetJewel or Food, Hide Jewel, Move Jewel or Food vs Deliver Leaflet
sp {moveJewel*getJewel*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name deliverLeaflet)
(<o2> ^name << moveJewel moveFood hideJewel getJewel eatFood seeEntityWithMemoryCount seeEntityWithoutMemoryCount avoidBrick moveDeliverySpot >>)
-->
(<s> ^operator <o> > <o2>)
}



#SPOT
sp {moveDeliverySpot*deliver*preferences
    (state <s> ^operator <o> +
               ^operator <o2> + )
    (<o> ^name moveDeliverySpot)
    (<o2> ^name << moveJewel >>)
-->
(<s> ^operator <o> > <o2>)
}

#JEWEL

# Move Jewel or Food vs Get Jewel
sp {moveJewel*deliver*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name getJewel)
(<o2> ^name << moveJewel moveFood hideJewel moveDeliverySpot >>)
-->
(<s> ^operator <o> > <o2>)
}

# Move Jewel or Food vs Hide Jewel
sp {moveJewel*hideJewel*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name hideJewel)
(<o2> ^name << moveJewel moveFood moveDeliverySpot >>)
-->
(<s> ^operator <o> > <o2>)} 
 

# Get Jewel vs SeeEntity
sp {getJewel*seeEntity*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name getJewel)
(<o2> ^name << seeEntityWithMemoryCount seeEntityWithoutMemoryCount >>)
-->
(<s> ^operator <o> > <o2>)} 

# Hide Jewel vs SeeEntity
sp {hideJewel*seeEntity*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name hideJewel)
(<o2> ^name << seeEntityWithMemoryCount seeEntityWithoutMemoryCount >>)
-->
(<s> ^operator <o> > <o2>)} 



# Get Jewel vs Avoid Brick
sp {getJewel*avoidBrick*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name getJewel)
(<o2> ^name avoidBrick)
-->
(<s> ^operator <o> > <o2>)
} 

# Hide Jewel vs Avoid Brick
sp {hideJewel*avoidBrick*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name hideJewel)
(<o2> ^name avoidBrick)
-->
(<s> ^operator <o> > <o2>)}

# Hide Jewel vs Get Jewel
sp {hideJewel*getJewel*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name getJewel)
(<o2> ^name hideJewel)
-->
(<s> ^operator <o> > <o2>)} 


# Move Jewel vs Move Jewel Preferences
sp {moveJewel*moveJewel*less*distance
(state <s> ^attribute operator 
           ^impasse tie
           ^item <o> {<> <o> <o2>}
           ^superstate <ss>)
(<ss> ^io.input-link <il>)
(<il> ^CREATURE <creature>)                 
(<o> ^name moveJewel)
(<o2> ^name moveJewel)
(<o2> ^parameter.distance <distance2>)
(<o>  ^parameter.distance <distance> <= <distance2>)
-->
(<ss> ^operator <o> > <o2>)} 

# Get Jewel vs Get Jewel Preferences
sp {getJewel*getJewel*preferences
(state <s> ^attribute operator 
           ^impasse tie
           ^item <o> {<> <o> <o2>}
           ^superstate <ss>)        
(<o> ^name getJewel)
(<o2> ^name getJewel)
(<o2> ^parameter.distance <distance2>)
(<o>  ^parameter.distance <distance> <= <distance2>)
-->
(<ss> ^operator <o> > <o2>)}

# Hide Jewel vs Hide Jewel Preferences
sp {hideJewel*hideJewel*preferences
(state <s> ^attribute operator 
           ^impasse tie
           ^item <o> {<> <o> <o2>}
           ^superstate <ss>)        
(<o> ^name hideJewel)
(<o2> ^name hideJewel)
(<o2> ^parameter.distance <distance2>)
(<o>  ^parameter.distance <distance> <= <distance2>)
-->
(<ss> ^operator <o> > <o2>)} 

# FOOD

# Move Food vs Eat Food
sp {moveFood*eatFood*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name eatFood)
(<o2> ^name << moveFood moveJewel moveDeliverySpot hideJewel getJewel >>)
-->
(<s> ^operator <o> > <o2>)} 

# Eat Food vs Avoid Brick
sp {eatFood*avoidBrick*preferences
(state <s> ^operator <o> + 
                     <o2> +)
(<o> ^name eatFood)
(<o2> ^name avoidBrick)
-->
(<s> ^operator <o> > <o2>)} 

# Move Food vs Move Food Preferences
sp {moveFood*moveFood*preferences
(state <s> ^attribute operator 
           ^impasse tie
           ^item <o> {<> <o> <o2>}
           ^superstate <ss>)        
(<o> ^name moveFood)
(<o2> ^name moveFood)
(<o2> ^parameter.distance <distance2>)
(<o>  ^parameter.distance <distance> <= <distance2>)
-->
(<ss> ^operator <o> > <o2>)} 

# Eat Food vs Eat Food Preferences
sp {eatFood*eatFood*preferences
(state <s> ^attribute operator 
           ^impasse tie
           ^item <o> {<> <o> <o2>}
           ^superstate <ss>)        
(<o> ^name eatFood)
(<o2> ^name eatFood)
(<o2> ^parameter.distance <distance2>)
(<o>  ^parameter.distance <distance> <= <distance2>)
-->
(<ss> ^operator <o> > <o2>)} 

# FOOD vs JEWEL

# Move Food vs Move Jewel Preferences - Move Food Wins
sp {moveFood*moveJewel*preferences*moveFoodWins
(state <s> ^attribute operator 
           ^impasse tie
           ^item <o> {<> <o> <o2>}
           ^superstate <ss>)
(<ss> ^io.input-link <il>)
(<o> ^name moveFood)
(<o2> ^name moveJewel)
(<il> ^CREATURE.PARAMETERS.MINFUEL <min>)
(<il> ^CREATURE.SENSOR.FUEL <fuel>)
(<fuel> ^VALUE <value> <= <min>)        
-->
(<ss> ^operator <o> > <o2>)} 

# Move Food vs Move Jewel Preferences - Move Jewel Wins
sp {moveFood*moveJewel*preferences*moveJewelWins
(state <s> ^attribute operator 
           ^impasse tie
           ^item <o> {<> <o> <o2>}
           ^superstate <ss>)
(<ss> ^io.input-link <il>)
(<o> ^name moveFood)
(<o2> ^name moveJewel)
(<il> ^CREATURE.PARAMETERS.MINFUEL <min>)
(<il> ^CREATURE.SENSOR.FUEL <fuel>)
(<fuel> ^VALUE <value> > <min>)               
-->
(<ss> ^operator <o2> > <o>)} 


#BRICK  

# Avoid Brick vs Avoid Brick Preferences
sp {avoidBrick*avoidBrick*without*move*jewel*preferences
(state <s> ^attribute operator 
           ^impasse tie
           ^item <o> {<> <o> <o2>}
           ^item-count <itemCount>
           ^superstate <ss>)        
(<o> ^name avoidBrick)
(<o2> ^name avoidBrick)
(<o2> ^parameter <distance2>)
(<o>  ^parameter <distance> <= <distance2>)
-->
(<ss> ^operator <o> > <o2>)}

# Avoid Brick vs Move Jewel vs Move Food Preferences with element in memory 
sp {avoidBrick*moveJewel*moveFood*preferences
(state <s> ^attribute operator 
           ^impasse tie
           ^item <o> {<> <o> <o2>}
           ^item-count <itemCount> 2
           ^superstate <ss>)        
(<o> ^name avoidBrick)
(<o2> ^name << moveJewel moveFood moveDeliverySpot >>)
(<o2> ^parameter <entity>)
(<entity> ^NAME <entityName>)
(<ss> ^io.input-link <il>)
(<il> ^CREATURE <creature>)
(<creature> ^MEMORY <memory>)
(<memory> ^ENTITY <entityInMemory>)
(<entityInMemory> ^NAME <entityName>)
-->
(<o> ^entityName <entityName>)
(<ss> ^operator <o> > <o2>)}

# WANDER

# Wander Preferences
sp {wander*preferences
(state <s> ^operator <o> +)
(<o> ^name wander)
-->
(<s> ^operator <o> <)}

# HALT

sp {halt*condition
  (state <s> ^impasse no-change ^type state -^operator ^attribute operator)
-->
  #(write I2)
  #(halt)
  (interrupt)
}